import re
import DyMat
import regex
import sys

# Execute the m2p() function with the appropriate inputs in a separate script as showed in the script *example.py*

def cleanBaseModelica(baseModelica):
    # Eliminating comments of the type /* ... */ and \" ... \"; 
    emptyLines = []
    for i,r in enumerate(baseModelica):
        if r == "\n":
            emptyLines.append(i)
            continue
        # Removing comments of the type /* ... */
        temp_row = re.sub("/\*.*\*/","",r)
        # Removing anything inside \" ... \"; with [^\"]* indicating any character except "
        temp_row = re.sub(r"(\"[^\"]*\");",";",temp_row) # strip anything inside \" ... \"; (semicolon!) 
        # The line above does not remove comments from line with function name definition but this is not an issue since the code takes care
        # of it in the function dictionary creation
        ###### temp_row = re.sub(r"(\"[^\"]*\")","",temp_row) # strip anything inside \" ... \" Detrimental for time tables!
        # Remove double \\; and replace them with single ;
        temp_row = re.sub(" \\\\;", ";", temp_row)
        # Remove single quotes
        temp_row = re.sub(r"\'", "", temp_row)
        # remove output keyword from variables lines
        temp_row = re.sub(r"(?<=\s)output(?=\s)", "", temp_row) 
        # remove spaces at the beginning of the line
        baseModelica[i] = temp_row.strip()
    
    for index in reversed(emptyLines):
        del baseModelica[index]

    # Removing initial lines of the file until "package PackageName" is found
    while True:
        if "package" in baseModelica[0]:
            try:
                line = re.search(r"^package\s", baseModelica[0]).group()
                modelName = baseModelica[0][8:]
                break
            except:
                del baseModelica[0]
            
        else:
            del baseModelica[0]
    # Removing lines between package and model keywords: they might contain functions which are not inlined and TimeTables and CombiTimeTables functions not uused for the translation
    while True:
        if f"model {modelName}" in baseModelica[0]:
            break
        else:
            del baseModelica[0]
    # Removing last line of the file recursively until package end is found
    while True:
        if f"end {modelName};" in baseModelica[-1]:
            break
        else:
            del baseModelica[-1]
    # Remove package end (now it's the last line of the file-list) and leave model end as last line
    del baseModelica[-1]

    return baseModelica

def removeIfInitial(baseModelica):
    # This function is emplyed to remove "if initial()" construct in the BaseModelica code
    rowsToCancel = []
    possibleIfInitialClause = False
    secondChunckIfInitialClause = False
    for index,row in enumerate(baseModelica):
        if row == "if initial() then":
            possibleIfInitialClause = True
            rowsToCancel.append(index)
        elif possibleIfInitialClause == True and secondChunckIfInitialClause == False:
            if row == "elseif true then":
                secondChunckIfInitialClause = True
            rowsToCancel.append(index)
        elif possibleIfInitialClause == True and secondChunckIfInitialClause == True:
            if row == "end if;":
                rowsToCancel.append(index)
                possibleIfInitialClause = False
                secondChunckIfInitialClause = False


    for index in reversed(rowsToCancel):
        del baseModelica[index]
    
    return baseModelica

def modelicaModelStructure(baseModelica):
    # New function to retrieve Modelica model structure: Initial Equation start, Equation start, Algorithm starts
    # There may be more than one algorithm section!

    initEqStart = None
    eqStart = None
    algoStarts = []
    
    for i, line in enumerate(baseModelica):
        if line == "initial equation":
            initEqStart = i
        elif line == "equation":
            eqStart = i
        elif line == "algorithm":
            algoStarts.append(i) 

    if initEqStart == None:
        initEqStart = eqStart

    return eqStart, initEqStart, algoStarts

def mapMatFileToOMC(initializationValues):
    # Some variables in Dymola have a space that is not present in OpenModelica... 
    # if a results file which is not generated by omc, than this function allows to use it
    dictInitValues = {}
    for name in initializationValues.names():
        omcName = re.sub(r"\s", "", name)
        dictInitValues[omcName] = name
    
    return dictInitValues

def extractAlgorithmSection(baseModelica, algoStarts):
    # Extracting from baseModelica the algorithm sections for later analysis. The search starts in reverse order and iterates from algorithm start until if finds a keyword for algorithm end.
    algoSections = {} # A dictionay containing the text of the algorithm sections
    for alg in reversed(algoStarts):
        algoSections[alg] = [baseModelica[alg]]
        index = alg+1
        while True:
            if (baseModelica[index] == "algorithm") or (baseModelica[index] == "initial equation") or (baseModelica[index] == "equation") or (baseModelica[index] == baseModelica[-1]):
                break
            else:
                algoSections[alg].append(baseModelica[index])
                del baseModelica[index]
        del baseModelica[alg]
    
    return baseModelica, algoSections

def timeTableHandler(baseModelica, equationStart):

    tableNames = []
    foundValueSection = False # indicates if the section of the baseModelica code that is being analyzed is referred to the values of a table or not

    tables = {} # Dict that will contain the baseModelica lines of the values of the tables (tableNames are the keys of the dict)
    combiTimeTableslist = [] # List with the names of the identified CombiTimeTables
    combiTimeTableslistOnFile = [] # List with the names of the identified CombiTimeTables with external file

    # The keywords (words that should be found in a row) to spot the beginning of a TimeTables or CombiTimeTables section are the following: 
    # ".table[" for TimeTables
    # ".tableOnFile = " for CombiTimeTables

    for row in baseModelica[0:equationStart]:
        if ".table[" in row or ".tableOnFile = " in row: # if it enters here, a TimeTable or a CombiTimeTable has been found!
            if ".table[" in row and ".tableOnFile = " not in row:
                # if it's a Timetable
                try:
                    # Look for a table value line pattern. For example "parameter Real tableName.table[1,1] = 1"
                    tableEntry = re.search(r"(?<=(parameter\sReal\s)).*\.table\[\d+\,\d+\]\s=.*(?=\;)", row).group()
                    if foundValueSection == False:
                        # If the line before was not a table, then the table section has just started and a new table name can be found and is added to the table dictionary
                        tableName = re.search(r"(?<=(parameter\sReal\s)).*(?=(\.table\[1\,1\]))",row).group()
                        if tableName not in tableNames:
                            tableNames.append(tableName)
                        tables[tableName] = {}
                        tables[tableName]["TableEntries"] = []
                        foundValueSection = True
                    tables[tableName]["TableEntries"].append(tableEntry)
                except AttributeError:
                    # This is not anymore a table section --> ready to store a new table name when found
                    foundValueSection = False
            
            elif ".tableOnFile = " in row: # if True, a CombiTimeTable has been found
                try:
                    combiName = re.search(r"(?<=(parameter\sBoolean\s)).*(?=(\.tableOnFile))",row).group() # Try to store the table name
                    combiTimeTableslist.append(combiName)
                    tableNames.append(combiName)
                    tables[combiName] = {}
                    if ".tableOnFile = true" in row:                        
                        combiTimeTableslistOnFile.append(combiName)                        
                except AttributeError:
                    print("Something is wrong: found '.tableOnFile' pattern but not a table name!\n")
                foundValueSection = False
            else:
                foundValueSection = False
                
        else:
            # This section is dedicated to tables attributes. they are all stored in the same dictionary as the values of the tables
            foundValueSection = False
            for name in tableNames: # For every table name that has already been found
                if name + "." in row:
                    if name+".timeScale" in row and ".timeScaled" not in row:
                        timeScale = re.search(r"(?<=(\)\s=\s)).*(?=(\s\\\"))", row).group()
                        tables[name]["timeScale"] = timeScale
                        break # might be unnecessary
                    elif name+".shiftTime" in row:
                        shiftTime = re.search(r"(?<=(\)\s=\s)).*(?=(;))", row).group()
                        tables[name]["shiftTime"] = shiftTime
                        break # might be unnecessary
                    elif name+".startTime" in row:
                        startTime = re.search(r"(?<=(\)\s=\s)).*(?=(;))", row).group()
                        tables[name]["startTime"] = startTime
                        break # might be unnecessary
                    elif name+".offset" in row:
                        offset = re.search(r"(?<=(\s=\s)).*(?=(;))", row).group()
                        try:
                            tables[name]["offset"].append(offset)
                        except KeyError:
                            tables[name]["offset"] = [offset]
                        break # might be unnecessary
                    elif name+".tableName" in row:
                        tableName = re.search(r"(?<=(\s=\s\\\")).*(?=(\\\";))",row).group()
                        tables[name]["tableName"] = tableName
                        break # might be unnecessary
                    elif name+".fileName" in row:
                        fileName = re.search(r"(?<=(\s=\s\\\")).*(?=(\\\";))",row).group()
                        tables[name]["fileName"] = fileName
                        break # might be unnecessary
                    elif name+".smoothness" in row:
                        smoothness = re.search(r"(?<=(\s=\s)).*(?=(;))",row).group()
                        tables[name]["smoothness"] = smoothness
                        break # might be unnecessary
                    elif name+".extrapolation" in row:
                        extrapolation = re.search(r"(?<=(\s=\s)).*(?=(;))",row).group()
                        tables[name]["extrapolation"] = extrapolation
                        break # might be unnecessary
    
    if tables == {}:
        # If no tables are found, exit
        return baseModelica, tables
    
    # The following for cycle is used to build the lists containing the lists for Time, y_1, y_2 and so on in a format suitable for the following functions to write Pyomo code 
    for tableName in tables.keys(): # For every table
        try:
            table = tables[tableName]["TableEntries"]
            nRows = eval(re.search(r"(?<=\[)\d+(?=\,)",table[-1]).group()) # Get the number of rows (and columns in the line below) from the last line of the table section
            nCols = eval(re.search(r"(?<=\,)\d+(?=\])",table[-1]).group())
            tables[tableName]["tableSeries"] = {}
            for indexC in range(1,nCols+1): # Iterate over the columns of the table 
                if indexC == 1:
                    tables[tableName]["tableSeries"]["Time"] = [] # First column is always Time
                else:
                    if tableName in combiTimeTableslist:
                        tables[tableName]["tableSeries"][f"y_{indexC-1}"] = []
                    else:
                        tables[tableName]["tableSeries"]["y"] = []
                for indexR in range(1,nRows+1): # Iterate over the rows to get the values of each series (Time or values)
                    for row in table:
                        try:
                            patternEntry = f"(?<=(\[{indexR},{indexC}\]\s=\s)).*"
                            tableEntry = re.search(patternEntry, row).group()
                            if indexC == 1:
                                tables[tableName]["tableSeries"]["Time"].append(eval(tableEntry))
                            else:
                                if tableName in combiTimeTableslist:
                                    tables[tableName]["tableSeries"][f"y_{indexC-1}"].append(eval(tableEntry))
                                else:
                                    tables[tableName]["tableSeries"]["y"].append(eval(tableEntry))
                        except:
                            pass
        except KeyError:
            continue # The values of the table are stored in an external file! Another function will handle this case in main()

    # Cleaning baseModelica from Tables related lines!
    patternToCancel = []
    for tableName in tables.keys():
        patternToCancel.append(f"{tableName}.timeScaled")
        patternToCancel.append(f"{tableName}.a")
        patternToCancel.append(f"{tableName}.b")
        patternToCancel.append(f"{tableName}.last")
        patternToCancel.append(f"{tableName}.nextEvent")
        patternToCancel.append(f"{tableName}.nextEventScaled")
        patternToCancel.append(f"{tableName}.nextTimeEvent")
        patternToCancel.append(f"{tableName}.nextTimeEventScaled")
    
    # Find rows to cancel by index
    rowToCancel = []
    for row in baseModelica:
        for pattern in patternToCancel:
            if pattern in row:
                rowToCancel.append(baseModelica.index(row))
                break
    # Remove the rows to cancel. This might leave when clauses chunks in the code if a CombiTimeTable is used
    for index in reversed(rowToCancel):
        del baseModelica[index]
    
    rowToCancel = []
    possibleWhenClauseFound = False
    # Remove the "" and "when" chunks left from previous eliminations from baseModelica
    for index,row in enumerate(baseModelica):
        if row == "":
            rowToCancel.append(index)
        if row[0:5] == "when ":
            possibleWhenClauseFound = True
        if row == "end when;" and possibleWhenClauseFound == False:
            rowToCancel.append(index)
            possibleWhenClauseFound = False
    
    for index in reversed(rowToCancel): # Delete the selected lines in reversed order
        del baseModelica[index]
        
    return baseModelica, tables

def timeTableOnFileHandler(timeTablesDict):
    # This function is employed to add to the time table dictionary the time and value series from external file tables
    for timeTable in timeTablesDict.keys():
        try:
            # Retrieve table file path and table name on file if present
            fileName = timeTablesDict[timeTable]["fileName"]
            if fileName == "NoName":
                continue
            tableNameOnFile = timeTablesDict[timeTable]["tableName"]
        except KeyError:
            # If the table is not in a file, continue with the next table
            continue

        with open(fileName) as my_file: # open the time table file and store separately each line in a list
            tableFileLines = my_file.readlines()
        # Here a for cycle starts to retrieve all the rows of the time table with named saved in "tableNameOnFile"
        table = []
        tableFound = False
        for i,line in enumerate(tableFileLines):
            tableFileLines[i] = line.strip() # Remove spaces from the beginning of each line of the file to make the table entry lines start with a digit
            updatedLineFirstCharacter = tableFileLines[i][0]
            if tableNameOnFile in tableFileLines[i]: # the table starts when a line containing its name is found
                tableFound = True # Set to True the flag indicating that the tables was found
            elif updatedLineFirstCharacter.isdigit() and tableFound == True: 
                # Since all the table lines start with a digit, if a table was found then the line starting with a digit belongs to the table
                newLineEntry = re.split(r"\s+", tableFileLines[i]) # Values in the rows are divided by spaces --> store just the numbers
                table.append(newLineEntry)
            elif not updatedLineFirstCharacter.isdigit() and tableFound == True:
                break # Table ended if the line does not start with a digit anymore
        
        # Iterating over the list of lists containing the time table. First column is the Time vector, while the other columns correspond to y_1, y_2 and so on
        nRows = len(table)
        nCols = len(table[0])
        timeTablesDict[timeTable]["tableSeries"] = {}
        for i in range(nCols):
            if i == 0:
                timeTablesDict[timeTable]["tableSeries"]["Time"] = []
            else:
                timeTablesDict[timeTable]["tableSeries"][f"y_{i}"] = []
            for j in range(nRows):
                if i == 0:
                    timeTablesDict[timeTable]["tableSeries"]["Time"].append(eval(table[j][i]))
                else:
                    timeTablesDict[timeTable]["tableSeries"][f"y_{i}"].append(eval(table[j][i]))

    return timeTablesDict

def timeTablesConstraintPyomoCode(timeTablesDict, modelName, staticOrDynamic):
    # First version of this function is 
    pyomoTableCode = []
    if staticOrDynamic == "Static":
        for tableName in timeTablesDict.keys():
            table = timeTablesDict[tableName]["tableSeries"]
            for output in table.keys():
                if output == "Time":
                    continue
                else:
                    string = f"{modelName}.{tableName}_{output}.fix({table[output][0]})\n"
                    pyomoTableCode.append(string)

    if staticOrDynamic == "Dynamic":
        for tableName in timeTablesDict.keys():
            if (timeTablesDict[tableName]["smoothness"] != "Modelica.Blocks.Types.Smoothness.ConstantSegments") or (timeTablesDict[tableName]["smoothness"] != "Modelica.Blocks.Types.Smoothness.LinearSegments"):
                print(f"Table {tableName} will linearly interpolate the data! Attention!")
            if timeTablesDict[tableName]["smoothness"] == "Modelica.Blocks.Types.Smoothness.ConstantSegments":
                # pyomoTableCode.append("from scipy.interpolate import make_interp_spline\n\n")
                pyomoTableCode.append("from scipy import interpolate\n\n")
            table = timeTablesDict[tableName]["tableSeries"]
            timeVector = table["Time"]
            for output in table.keys():
                if output == "Time":
                    continue
                else:
                    valueVector = table[output]
                    string = f"{tableName}_{output}_time = {timeVector}\n"
                    string += f"{tableName}_{output}_values = {valueVector}\n"
                    if timeTablesDict[tableName]["smoothness"] == "Modelica.Blocks.Types.Smoothness.ConstantSegments":
                        # string += f"f{output} = make_interp_spline({tableName}_{output}_time, {tableName}_{output}_values, k=0)\n"
                        string += f"f{output} = interpolate.interp1d({tableName}_{output}_time, {tableName}_{output}_values, kind = 'previous')\n"
                        string += f"{tableName}_{output}_interp = f{output}(timeSteps)\n"
                    else:
                        string += f"{tableName}_{output}_interp =  np.interp(timeSteps, {tableName}_{output}_time, {tableName}_{output}_values)\n"
                    string += f"for i,j in zip(timeSteps,range(len(timeSteps))):\n\t{modelName}.{tableName}_{output}[i].fix({tableName}_{output}_interp[j])\n\n"
                    # print(string)
                    pyomoTableCode.append(string)
                    pass

    return pyomoTableCode

def extractStepsAndRamps(baseModelica, equationStart):
    # This function is employed to extract the informations regarding steps and ramps blocks in Modelica
    stepsAndRamps = {}
    rowsToCancel = []

    for index, row in enumerate(baseModelica[equationStart+1:]):
        if "(if time < " in row:
            if " else if time < " in row:
                entries = re.search(r"=\s([\d\.]+)\s\+\s\(if\stime\s<\s([\d\.]+)\sthen\s([\d\.]+)\selse\sif\stime\s<\s([\d\.]+)\sthen\s(.+)\selse\s([\d\.]+)\);", row).groups()
            else:
                entries = re.search(r"=\s([\d\.]+)\s\+\s\(if\stime\s<\s([\d\.]+)\sthen\s([\d\.]+)\selse\s([\d\.]+)\);", row).groups()
 
            name = re.search(r"^.+(?=(\s=))", row).group()  
            name = re.sub(r"\.","_", name)
            stepsAndRamps[name] = entries
            rowsToCancel.append(index+equationStart+1)
        elif "if time < " in row:
            if " else if time < " in row:
                entries = re.search(r"if\stime\s<\s([\d\.]+)\sthen\s([\d\.]+)\selse\sif\stime\s<\s([\d\.]+)\sthen\s(.+)\selse\s([\d\.]+);", row).groups()
            else:
                entries = re.search(r"if\stime\s<\s([\d\.]+)\sthen\s([\d\.]+)\selse\s([\d\.]+);", row).groups()

            name = re.search(r"^.+(?=(\s=))", row).group() 
            name = re.sub(r"\.","_", name)
            stepsAndRamps[name] = entries
            rowsToCancel.append(index+equationStart+1)

    for indexRow in reversed(rowsToCancel):
        del baseModelica[indexRow]

    return baseModelica, stepsAndRamps

def pyomoStepAndRamps(stepsAndRamps, modelName):
    # This function writes the Pyomo code to translate step and ramp blocks
    pyomoString = ["for h in timeSteps:\n"]
    for varName in stepsAndRamps.keys():
        if len(stepsAndRamps[varName]) == 3:
            # This is a step without offset
            startTime = stepsAndRamps[varName][0]
            valueBefore = stepsAndRamps[varName][1]
            valueAfter = stepsAndRamps[varName][2]
            stringStep = f"\tif h < {startTime}:\n\t\t{modelName}.{varName}[h].fix({valueBefore})\n\telse:\n\t\t{modelName}.{varName}[h].fix({valueAfter})\n"
            pyomoString.append(stringStep)
        elif len(stepsAndRamps[varName]) == 4:
            # This is a step with offset
            offset = stepsAndRamps[varName][0]
            startTime = stepsAndRamps[varName][1]
            valueBefore = stepsAndRamps[varName][2]
            valueAfter = stepsAndRamps[varName][3]
            stringStep = f"\tif h < {startTime}:\n\t\t{modelName}.{varName}[h].fix({valueBefore} + {offset})\n\telse:\n\t\t{modelName}.{varName}[h].fix({valueAfter} + {offset})\n"
            pyomoString.append(stringStep)
        elif len(stepsAndRamps[varName]) == 5:
            # This is a ramp without offset
            startTime = stepsAndRamps[varName][0]
            valueBefore = stepsAndRamps[varName][1]
            stopTime = stepsAndRamps[varName][2]
            exprDuringRamp = stepsAndRamps[varName][3]
            exprDuringRamp = exprDuringRamp.replace("time", "h")
            valueAfter = stepsAndRamps[varName][4]
            stringRamp = f"\tif h < {startTime}:\n\t\t{modelName}.{varName}[h].fix({valueBefore})\n\telif h < {stopTime}:\n\t\t{modelName}.{varName}[h].fix({exprDuringRamp})\n\telse:\n\t\t{modelName}.{varName}[h].fix({valueAfter})\n"
            pyomoString.append(stringRamp)
        elif len(stepsAndRamps[varName]) == 6:
            # This is a ramp with offset
            offset = stepsAndRamps[varName][0]
            startTime = stepsAndRamps[varName][1]
            valueBefore = stepsAndRamps[varName][2]
            stopTime = stepsAndRamps[varName][3]
            exprDuringRamp = stepsAndRamps[varName][4]
            exprDuringRamp = exprDuringRamp.replace("time", "h")
            valueAfter = stepsAndRamps[varName][5]
            stringRamp = f"\tif h < {startTime}:\n\t\t{modelName}.{varName}[h].fix({valueBefore} + {offset})\n\telif h < {stopTime}:\n\t\t{modelName}.{varName}[h].fix({exprDuringRamp} + {offset})\n\telse:\n\t\t{modelName}.{varName}[h].fix({valueAfter} + {offset})\n"
            pyomoString.append(stringRamp)
        else:
            print("Error handling the data for step and ramps!")
    
    pyomoString.append("\n\n")

    return pyomoString


def varsDict(baseModelica, initialEquationStart, initializationValues = None, dictInitValues = None):
    # This function creates a dictionary for variables and their properties (min, max, nominal, initialize) (stored in a nested dictionary)

    # Instantiate empty dictionary for variables
    variablesDict = dict()
    # Iterate the baseModelica list from the start of the model to the beginning of the equations section
    for row in baseModelica[1:initialEquationStart]:
        if "Real" in row:
            if "parameter" in row or "constant" in row:
                # Skip the row if it is a parameter or a constant beacuse all parameters and constants are replaced in the equations with their values
                pass
            else:
                try:
                    # If the row starts with Real and does not contain parameter or constant, the variable name is the first word after Real (non-greedy search)
                    varName = re.search(r"(?<=(^Real\s))\S*?(?=(\(|;|\s=))", row).group()
                except AttributeError:
                    print(f"Could not find a name for this row: {row}")
                    break
                # Instantiate dict for variable found
                variablesDict[varName] = dict()
                # Clean the variable name from square brackets
                # cleanVarName = re.sub(r"[\[\]]", "", varName) # This line is dangerous with vector variables...
                # Better to substitute [ with _ and then remove ], so that y1 stays y1 and y[1] becomes y_1 instead of y1
                cleanVarName = re.sub(r"[\[]", "_", varName)
                cleanVarName = re.sub(r"[\]]", "", cleanVarName)
                # Substitute dots with underscores
                cleanVarName = re.sub(r"\.","_", cleanVarName)
                cleanVarName = re.sub(r"\,","_", cleanVarName)
                # Store the variable name in the dictionary as pyomoName
                variablesDict[varName]["pyomoName"] = cleanVarName
                # Look for minimum, maximum and nominal values
                if "min = " in row:
                    try:
                        minimum = re.search(r"(?<=(min = ))[0-9.]+e{0,1}[e\-]{0,1}[0-9]*", row).group()
                    except AttributeError:
                        minimum = None
                else:
                    minimum = None
                if "max = " in row:
                    try:
                        maximum = re.search(r"(?<=(max = ))[0-9.]+e{0,1}[e\-]{0,1}[0-9]*", row).group()
                    except AttributeError:
                        maximum = None
                else:
                    maximum = None
                if "nominal = " in row:
                    try:
                        nominal = re.search(r"(?<=(nominal = ))[0-9.]+e{0,1}[e\-]{0,1}[0-9]*", row).group()
                    except AttributeError:
                        nominal = 1
                else:
                    nominal = 1
                # Store the values in the dictionary
                variablesDict[varName]["min"] = minimum if minimum != None else None #+ "+1e-9"
                variablesDict[varName]["max"] = maximum
                variablesDict[varName]["nominal"] = nominal
                # Assign an initial value to the variable
                if initializationValues != None:
                    counter = 0
                    try:
                        # Try to find in Dymat dictionary the initial value for the variable
                        # Picking the last value of the simulation as initial value
                        initValue = initializationValues[dictInitValues[varName]][0]
                        # Check if it exceeds min and max
                        if minimum != None:
                            if float(initValue) < float(minimum):
                                initValue = minimum
                                counter += 1
                                # print(f"Warning! {varName} exceeds its minimum")
                        if maximum != None:
                            if float(initValue) > float(maximum):
                                initValue = maximum
                                counter += 1
                                print(f"Warning! {varName} exceeds its maximum")
                        if counter > 2:
                            print("Counter min-max > 2! ERROR!!")
                        # Store the initial value in the dictionary
                        variablesDict[varName]["initialize"] = initValue
                    except KeyError:
                        print(f"Could not find an init value for the variable in this row: {row}\nMaybe it is a protected variable! If so, please include it in the results file!")
                else:
                    # If no initial values are used, the variable is initialized to 0
                    variablesDict[varName]["initialize"] = 0
        else:
            # This is a check to see if the translation from Modelica to BaseModelica was correct
            if "parameter" not in row and "constant" not in row:
                print("\n Error, a variable is not a Real, but a Boolean or an Integer")
    return variablesDict


def textVarPyomoCode(variablesDict, modelName, staticOrDynamic, initTrajectory, bounds):
    # Create a list with Pyomo code for each variable: instantiation and normalization
    varPyomoCode = []
    for var in variablesDict.keys():
        # Creat first part of the instantiation string: model.x = Var(
        defString = modelName + "." + variablesDict[var]["pyomoName"] + " = Var("
        # Set a domain for the variable if needed (time for dynamic simulation)
        if staticOrDynamic == "Dynamic":
            defString += "m.time, "
        # Set min and max for the variable if needed
        if bounds:
            # Here I wanted to avoid var initialization during var declaration when Dynamic initTrajectory is considered, but it might be a bad idea... so here the distinction is 
            # commented and not use for the moment. The related commented lines have a ###INITtraj comment at the end
            try:
                # if initTrajectory == "Constant": ###INITtraj
                defString += "initialize = " + str(variablesDict[var]["initialize"]) + ", bounds = (" +  str(variablesDict[var]["min"]) + "," + str(variablesDict[var]["max"]) + ")" + ", within = Reals)" # string with bounds
                # elif initTrajectory == "Dynamic": ###INITtraj
                    # defString += "bounds = (" +  str(variablesDict[var]["min"]) + "," + str(variablesDict[var]["max"]) + ")" + ", within = Reals)" # string with bounds ###INITtraj
            except KeyError:
                print("Min or Max value not found for variable: ", var)
        else:
            # if initTrajectory == "Constant": ###INITtraj
            defString += "initialize = " + str(variablesDict[var]["initialize"]) + ", within = Reals)" # string without bounds
            # elif initTrajectory == "Dynamic": ###INITtraj
                # defString += "within = Reals)" # string without bounds ###INITtraj
        
        # Compose the string for the normalization factor: max(|nominal|, |initialize|)
        normString = modelName + f".scaling_factor[{modelName}." + variablesDict[var]["pyomoName"] + "] = 1/max(" + str(abs(float(variablesDict[var]["nominal"]))) + "," + str(abs(float(variablesDict[var]["initialize"]))) + ")"
        # Append the strings to the list
        varPyomoCode.append(defString)
        varPyomoCode.append("\n")
        varPyomoCode.append(normString)
        varPyomoCode.append("\n")
    
    varPyomoCode.append("\n")
    return varPyomoCode

def textDERpyomoCode(statesDict, modelName, initializationValues, dictInitValues):
    # Create a list with Pyomo code for each derivative: instantiation and normalization
    # Recognize derivative var pattern in the results dictionary
    stateToDerMap = {}
    for name in list(initializationValues.names()):
        if "der(" in name:
            stateName = name.replace("der(","")
            stateName = stateName.replace(")","")
            stateToDerMap[stateName] = name

    DERpyomoCode = []
    for key in statesDict.keys():
        state = statesDict[key]
        # Create the string for the derivative Var instantiation (Derivatives are initialized to zero at the moment since the model we are studying use steady-state initialization)
        derVarInit = f"initializationValues['{stateToDerMap[dictInitValues[key]]}'][0]"
        stringDer = f"{modelName}.DER" + state + f" = DerivativeVar({modelName}.{state}, initialize = {eval(derVarInit)})" # composing the string for the derivative
        DERpyomoCode.append(stringDer)
        DERpyomoCode.append("\n")
        # Normalization string for the derivative
        stringNormDer = f"if abs(value({modelName}.{state}[m.time.ordered_data()[0]]) == 0):\n\t{modelName}.scaling_factor[{modelName}.DER{state}] = 1\nelse:\n\t{modelName}.scaling_factor[{modelName}.DER{state}] = 1/(abs(value({modelName}.{state}[m.time.ordered_data()[0]]))/dt)"
        # stringNormDer = f"{modelName}.scaling_factor[{modelName}.DER{state}] = 1/(abs(value({modelName}.{state}[m.time.at(2)]))/dt)" # OLD STRING
        stringNormDer = f"{modelName}.scaling_factor[{modelName}.DER{state}] = {modelName}.scaling_factor[{modelName}.{state}]*dt" # Employing scaling factor of state 
        DERpyomoCode.append(stringNormDer)
        DERpyomoCode.append("\n")
    return DERpyomoCode

def initialConditionsPyomoCode(modelName, initMode, baseModelica, equationStart, initialEquationStart, 
                                  statesDict, initializationValues = None, dictInitValues = None):
    
    # Function to write the code for the initial conditions of a dynamic optimization problem
    # It has two different modes:
    # 1 - KEEP-MODELICA: transcribe initial equations from Base Modelica
    # 2 - FIX-STATES: use the results file to fix the initial values of variables appearing in der operator

    # These are lines to handle the case in which no initial equation is provided --> return empty list of lines for initial equations
    if initMode == "KEEP-MODELICA" and (initialEquationStart == equationStart or initialEquationStart+1 == equationStart):
        initialConditionsCode = []
        return initialConditionsCode
    elif initMode == "FIX-STATES" and len(statesDict) == 0:
        initialConditionsCode = []
        return initialConditionsCode
    
    # Function to add model_name before every variable (not log, sqrt, exp, sin)
    def replace(match):
        word = match.group(0)
        if word in ["log", "sqrt", "exp", "sin", "cos"]:
            return word
        else:
            return modelName + "." + word
    
    def addInitialIndex(match):
        # Function to add [0] index to variables
        word = match.group(0)
        if word in ["log", "sqrt", "exp", "cos", "sin"]:
            return word
        else:
            return word + "[tStart]"
    
    if initMode == "FIX-STATES":
        initialConditionsCode = [f"def _init({modelName}):\n"]
        for state in statesDict.keys():
            # Look for the initial value of the state in the initializationValues dictionary (DyMat)
            try:
                valueInit = initializationValues[dictInitValues[state]][0]
            except:
                valueInit = 0
            # Append to the list of Pyomo code the string for the initial condition
            initialConditionsCode.append(f"    yield {modelName}.{statesDict[state]}[0] == {valueInit}\n")
        initialConditionsCode.append("    yield ConstraintList.End\n\n")
        # Instantiate constraints for the initial conditions with ConstraintList
        initialConditionsCode.append(f"{modelName}.init_conditions = ConstraintList(rule=_init)\n")
    
    elif initMode == "KEEP-MODELICA":
        initialConditionsCode = [f"def _init({modelName}):\n"] # start the list of lines with initial line: function declaration for initial constraints
        # Variable containing the pattern to substitute variables to add a trailing [0] index for dynamic problems
        patternDynConstr = fr'\b({modelName}\.\w*)\b'
        for row in baseModelica[initialEquationStart+1:equationStart]:
            if " homotopy(" in row:
                try:
                    # Look for homotopy expressions and substitute them with the actual expression
                    homotopyString = regex.search("homotopy(\((?:[^()]+|(?1))*\))", row).group()
                    # Divide between actual and simplified expression
                    homotopyComponents = re.split(",", homotopyString)
                    if len(homotopyComponents) > 2: # Just a check that they are actually the actual and the simplified parts
                        print("ERROR!!!")
                    # In the first split group, take the actual expression after removing "homotopy(" from the string
                    completeExpression = homotopyComponents[0][9:]
                    # Substitute the homotopy expression with the actual expression
                    row = regex.sub("homotopy(\((?:[^()]+|(?1))*\))", completeExpression, row)
                except AttributeError:
                    pass
            if " abs(" in row:
                try:
                    # Look for abs() and substitute them with sqrt of square
                    absRow = regex.search("\sabs(\((?:[^()]+|(?1))*\))", row).group()
                    completeExpression = f"sqrt(" + absRow[4:] + "^2)"
                    row = regex.sub("abs(\((?:[^()]+|(?1))*\))", completeExpression, row)
                except AttributeError:
                    pass
            
            # Turning the line into Pyomo style
            cleanRow = re.sub(r"[\[]", "_", row) # stripping square brackets
            cleanRow = re.sub(r"[\]]", "", cleanRow) # stripping square brackets
            cleanRow = re.sub(r"sqrt\(|exp\(|log\(|sin\(|cos\(", r"\g<0> ", cleanRow) # Adding space after log(, exp(, sqrt(
            cleanRow = regex.sub(r"[a-zA-Z]+?\S*?\K\.", r"_", cleanRow) # removing dots from variable names
            cleanRow = regex.sub(r"[a-zA-Z]+?\S*?\K\,", r"_", cleanRow) # removing commas from variable names
            cleanRow = regex.sub(r'der\((\w+)\)', r'DER\1', cleanRow) # Replace der() with DER...
            cleanRow = re.sub(r'\b([a-zA-Z_]\w*)\b', replace, cleanRow) # adding model name to variables (they must start with a letter!!) m.x
            cleanRow = re.sub(r"=", "==", cleanRow) # changing = into ==
            cleanRow = re.sub(r"\^", "**", cleanRow) # changing ^ into **
            cleanRow = re.sub(r";", "", cleanRow) # removing semicolumns
            cleanRow = re.sub(patternDynConstr, addInitialIndex, cleanRow) # adding time index to variables ([t])      
            initialConditionsCode.append(f"    yield {cleanRow}\n")
        
        initialConditionsCode.append("    yield ConstraintList.End\n\n") # Final line of the function to define initial constraints
        # Instantiate constraints for the initial conditions with ConstraintList
        initialConditionsCode.append(f"{modelName}.init_conditions = ConstraintList(rule=_init)\n")
    
    return initialConditionsCode

def addTimeIndex(match):
        # Function to add time index to variables if dynamic problem is considered
        word = match.group(0)
        if word in ["log", "sqrt", "exp", "cos", "sin"]:
            return word
        else:
            return word + "[t]"

def modelicaToPyomoVarName(varName):
    cleanVarName = re.sub(r"[\[]", "_", varName)
    cleanVarName = re.sub(r"[\]]", "", cleanVarName)
    cleanVarName = re.sub(r"\.","_", cleanVarName)
    return cleanVarName


def textConstraintsPyomoCode(baseModelica, equationStart, modelName, variablesDict, staticOrDynamic, subLog = False, norm = True, varFixing = True):
    # Create the Pyomo code for the constraints

    # Function to add model_name before every variable (not log, sqrt, exp, sin)
    def replace(match):
        word = match.group(0)
        if word in ["log", "sqrt", "exp", "sin", "cos"]:
            return word
        else:
            return modelName + "." + word
    
    def find_log_args(s):
        # Function to find the arguments of the log function in a string
        args = []
        depth = 0
        start = 0
        for i, c in enumerate(s):
            if c == 'l' and s[i:i+4] == 'log(':
                if depth == 0:
                    start = i + 4
                depth += 1
            elif c == '(' and depth > 0 and i != start-1:
                depth += 1
            elif c == ')' and depth > 0:
                depth -= 1
                if depth == 0:
                    args.append(s[start:i])
        return args
    # Variable containing the pattern to substitute variables to add a trailing [t] index for dynamic problems
    patternDynConstr = fr'\b({modelName}\.\w*)\b'
    # Empty list to store the Pyomo code for the constraints
    constraintsPyomoCode = []
    # Empty dictionary to store the states and their corresponding Pyomo variables
    statesDict = dict()
    i = 1 # Counter for constraints
    # List for the constraints that substitute log with exp (addition to the original constraints of the model) 
    subLogAddConstr = []
    # List for the arguments of the logs to substitute... it is filled with the arguments after they are substituted and it is used to check if an argument has been already substituted to avoid duplicates
    logArgs = []
    # The argument of a log is substituted with a variable uxxx, where xxx is the index of the argument in the list logArgs... the dict below stores the indexes and the corresponding arguments
    replVarLogDict = {}
    normLogList = []
    # Iterate from the beginning of the equation section to the end of the model
    for row in baseModelica[equationStart+1:-1]:
        if "assert(" in row or "annotation(" in row:
            # Skip line and go to the next iteration if assert is present in the line
            continue
        elif "if " in row and " then" in row:
            # Look for if statements and skip the row if found
            try:       
                re.search(r"if\s.*?\sthen", row).group()
                print(f"THERE IS AN IF STATEMENT!! --> {row}")
                continue
            except AttributeError:
                print("Detected if - then structure but the regex search did not find the pattern")
        else:
            if " homotopy(" in row:
                try:
                    # Look for homotopy expressions and substitute them with the actual expression
                    homotopyString = regex.search("homotopy(\((?:[^()]+|(?1))*\))", row).group()
                    # Divide between actual and simplified expression
                    homotopyComponents = re.split(",", homotopyString)
                    if len(homotopyComponents) > 2: # Just a check that they are actually the actual and the simplified parts
                        print("ERROR!!!")
                    # In the first split group, take the actual expression after removing "homotopy(" from the string
                    completeExpression = homotopyComponents[0][9:]
                    # Substitute the homotopy expression with the actual expression
                    row = regex.sub("homotopy(\((?:[^()]+|(?1))*\))", completeExpression, row)
                except AttributeError:
                    pass
            
            # Look for equations of the type a = \d*; --> they will be converted into m.a.fix(...) (\d* stands for a generic number))
            fixingPattern = re.search(r'^\s*[a-zA-Z0-9_.\[\]]+\s=\s[0-9.]+e{0,1}[e\-]{0,1}[0-9]*\s{0,1}[^+*^/\-]+$',row)
            if fixingPattern != None and varFixing == True:
                # Divide the row in LHS and RHS
                LHS = row.split("=")[0].strip(" ")
                RHS = row.split("=")[1].strip(" ")[:-1]
                # The line above should do if the last character after the numerical value is just a ;... if this does not work, the commented line below should be used
                # RHS = re.search(r'[0-9.]+e{0,1}[e\-]{0,1}[0-9]*', RHS).group()
                # Composition of the string for variable fixing
                fixString = modelName + "." + variablesDict[LHS]["pyomoName"] + ".fix(" + str(RHS) + ")"
                constraintsPyomoCode.append(fixString)
                constraintsPyomoCode.append("\n\n")
            else:
                # Division between static and dynamic constraints
                if staticOrDynamic == "Static":
                    cleanRow = re.sub(r"[\[]", "_", row) # stripping square brackets
                    cleanRow = re.sub(r"[\]]", "", cleanRow) # stripping square brackets
                    cleanRow = re.sub(r"sqrt\(|exp\(|log\(|sin\(|cos\(", r"\g<0> ", cleanRow) # Adding space after log(, exp(, sqrt( to separate every variable from other letters
                    cleanRow = regex.sub(r"[a-zA-Z]+?\S*?\K\.", r"_", cleanRow) # removing dots from variable names
                    cleanRow = regex.sub(r"[a-zA-Z]+?\S*?\K\,", r"_", cleanRow) # removing commas from variable names
                    cleanRow = regex.sub(r"der\(.*?\)", "0", cleanRow) # removing derivatives and setting them to 0 (JUST FOR STATIC PROBLEM!)
                    cleanRow = re.sub(r'\b([a-zA-Z_]\w*)\b', replace, cleanRow) # adding model name to variables (they must start with a letter!!) through function replace
                    cleanRow = re.sub(r"=", "==", cleanRow) # changing = into ==
                    cleanRow = re.sub(r"\^", "**", cleanRow) # changing ^ into **
                    cleanRow = re.sub(r";", "", cleanRow) # removing semicolumns
                    if subLog:
                        # Substituting logs with exponential equivalent: log(x) --> u and exp(u) = x
                        if "log(" in cleanRow:
                            # List of all the arguments of the logs in the row
                            logArgsTemp = find_log_args(cleanRow)
                            for elem in logArgsTemp:
                                if "log(" in elem:
                                    print("log inside log! Error!")
                                if elem not in logArgs:
                                    # If the same argument has been already replaced go to else to add just the substitution log(x) --> u and not the constraint exp(u) = x
                                    logArgs.append(elem)
                                    # Substituting the log with a variable in the original row (log(x) --> u)
                                    cleanRow = re.sub(re.escape("log(" + elem + ")"),f"{modelName}.u{logArgs.index(elem)+1}",cleanRow)
                                    # Adding the constraint for the substitution (exp(u) = x)
                                    subLogAddConstr.append(f"def _constrSubLog{i}_{logArgs.index(elem)+1}(m):\n" + f"    return 0 == exp( {modelName}.u{logArgs.index(elem)+1}) - ({elem})\n\n")
                                    subLogAddConstr.append(modelName + f".constrSubLog{i}_{logArgs.index(elem)+1} = Constraint(rule = _constrSubLog{i}_{logArgs.index(elem)+1})\n\n")
                                    replVarLogDict[logArgs.index(elem)+1] = elem
                                else:
                                    # The log arg has been already substituted once
                                    cleanRow = re.sub(re.escape("log(" + elem + ")"),f"{modelName}.u{logArgs.index(elem)+1}",cleanRow)
                    # Constraint instantiation
                    constrString = modelName + f".constr{i} = Constraint(expr = " + cleanRow + ")"
                    constraintsPyomoCode.append(constrString)
                    constraintsPyomoCode.append("\n\n")
                    # Update constraint index
                    i += 1
                elif staticOrDynamic == "Dynamic":
                    # Identify if derivatives are present in the row
                    if "der(" in row:
                        derivative = True
                        # Store state in a list
                        listOfStatesModelica = regex.findall(r"der\((.*?)\)", row)
                        # print()
                    else:
                        derivative = False
                    cleanRow = re.sub(r"[\[]", "_", row) # stripping square brackets
                    cleanRow = re.sub(r"[\]]", "", cleanRow) # stripping square brackets
                    cleanRow = re.sub(r"sqrt\(|exp\(|log\(|sin\(|cos\(", r"\g<0> ", cleanRow) # Adding space after log(, exp(, sqrt(
                    cleanRow = regex.sub(r"[a-zA-Z]+?\S*?\K\.", r"_", cleanRow) # removing dots from variable names
                    cleanRow = regex.sub(r"[a-zA-Z]+?\S*?\K\,", r"_", cleanRow) # removing commas from variable names
                    if derivative:
                        # If at least a derivative is present, create a dictionary with the states as key and their corresponding Pyomo variables as argument
                        listOfStatesPyomo = regex.findall(r"der\((\w+)\)", cleanRow)
                        statesDictrow = dict(zip(listOfStatesModelica, listOfStatesPyomo))
                        statesDict.update(statesDictrow)
                    cleanRow = regex.sub(r'der\((\w+)\)', r'DER\1', cleanRow) # Replace der() with DER...
                    cleanRow = re.sub(r'\b([a-zA-Z_]\w*)\b', replace, cleanRow) # adding model name to variables (they must start with a letter!!) m.x
                    cleanRow = re.sub(r"=", "==", cleanRow) # changing = into ==
                    cleanRow = re.sub(r"\^", "**", cleanRow) # changing ^ into **
                    cleanRow = re.sub(r";", "", cleanRow) # removing semicolumns
                    cleanRow = re.sub(patternDynConstr, addTimeIndex, cleanRow) # adding time index to variables ([t])
                    if subLog:
                        # Same logic as for static problems, but with the addition of the time index for log to exp substitution
                        if "log(" in cleanRow:
                            logArgsTemp = find_log_args(cleanRow)
                            for elem in logArgsTemp:
                                if "log(" in elem:
                                    print("log inside log! Error!")
                                if elem not in logArgs:
                                    logArgs.append(elem)
                                    cleanRow = re.sub(re.escape("log(" + elem + ")"),f"{modelName}.u{logArgs.index(elem)+1}[t]",cleanRow)
                                    subLogAddConstr.append(f"def _constrSubLog{i}_{logArgs.index(elem)+1}(m,t):\n" + f"    return 0 == exp( {modelName}.u{logArgs.index(elem)+1}[t]) - ({elem})\n")
                                    subLogAddConstr.append(modelName + f".constrSubLog{i}_{logArgs.index(elem)+1} = Constraint({modelName}.time, rule = _constrSubLog{i}_{logArgs.index(elem)+1})\n\n")
                                    # replVarLogDict[logArgs.index(elem)+1] = re.sub(r"\[t\]", r"[m.time.ordered_data()[0]]",elem) # Qui mettere solo elem per poi fare la sostituzione dopo
                                    replVarLogDict[logArgs.index(elem)+1] = elem
                                else:
                                    cleanRow = re.sub(re.escape("log(" + elem + ")"),f"{modelName}.u{logArgs.index(elem)+1}[t]",cleanRow)
                                
                    if derivative:
                        # If the equation has a derivative, avoid writing the constraint for index [0] beacuse an initial condition for that state will be defined 
                        constrString = f"def _constr{i}(m,t):\n    if t == 0:\n        return Constraint.Skip\n" + f"    return {cleanRow}\n"
                    else:
                        constrString = f"def _constr{i}(m,t):\n" + f"    return {cleanRow}\n"
                    constrString += modelName + f".constr{i} = Constraint({modelName}.time, rule = _constr{i})\n\n"
                    constraintsPyomoCode.append(constrString)
                    i += 1
                else:
                    print("Error: ")
    
    allConstraintsPyomoCode = [constraintsPyomoCode, subLogAddConstr]
    return allConstraintsPyomoCode, statesDict, replVarLogDict


def fixedFalseParams(baseModelica, modelName, initialEquationStart, equationStart, staticOrDynamic, initializationValues, dictInitValues):
    def replace(match):
        word = match.group(0)
        if word in ["log", "sqrt", "exp", "sin", "cos"]:
            return word
        else:
            return modelName + "." + word
        
    def addInitialIndex(match):
        # Function to add [0] index to variables
        word = match.group(0)
        if word in ["log", "sqrt", "exp", "cos", "sin"]:
            return word
        else:
            return word + "[tStart]"
        
    listVarParam = []
    listExtraVars = []
    listExtraConstr = []
    patternDynConstr = fr'\b({modelName}\.\w*)\b'
    i = 1
    for row in baseModelica[1:initialEquationStart]:
        if "fixed = false" in row:
            varParam = regex.search(r"(?<=(final\sparameter|parameter)\sReal\s)[\w\.]+", row).group()
            listVarParam.append(varParam)
    for row in baseModelica[initialEquationStart+1:equationStart]:
        for varParam in listVarParam:
            if varParam in row:
                if " homotopy(" in row:
                    try:
                        # Look for homotopy expressions and substitute them with the actual expression
                        homotopyString = regex.search("homotopy(\((?:[^()]+|(?1))*\))", row).group()
                        # Divide between actual and simplified expression
                        homotopyComponents = re.split(",", homotopyString)
                        if len(homotopyComponents) > 2: # Just a check that they are actually the actual and the simplified parts
                            print("ERROR!!!")
                        # In the first split group, take the actual expression after removing "homotopy(" from the string
                        completeExpression = homotopyComponents[0][9:]
                        # Substitute the homotopy expression with the actual expression
                        row = regex.sub("homotopy(\((?:[^()]+|(?1))*\))", completeExpression, row)
                    except AttributeError:
                        pass
                if " abs(" in row:
                    try:
                        # Look for abs() and substitute them with sqrt of square
                        absRow = regex.search("\sabs(\((?:[^()]+|(?1))*\))", row).group()
                        completeExpression = f"sqrt(" + absRow[4:] + "^2)"
                        row = regex.sub("abs(\((?:[^()]+|(?1))*\))", completeExpression, row)
                    except AttributeError:
                        pass

                varParamPyomo = modelicaToPyomoVarName(varParam)
                if staticOrDynamic == "Static":
                    stringExtraVar = f"{modelName}.{varParamPyomo} = Var(within = Reals)\n"
                    listExtraVars.append(stringExtraVar)
                    if initializationValues != None:
                        listExtraConstr.append(f"{modelName}.{varParamPyomo}.fix({initializationValues[dictInitValues[varParam]][0]})\n\n")
                    else:
                        cleanRow = re.sub(r"[\[]", "_", row) # stripping square brackets
                        cleanRow = re.sub(r"[\]]", "", cleanRow) # stripping square brackets
                        cleanRow = re.sub(r"sqrt\(|exp\(|log\(|sin\(|cos\(", r"\g<0> ", cleanRow) # Adding space after log(, exp(, sqrt( to separate every variable from other letters
                        cleanRow = regex.sub(r"[a-zA-Z]+?\S*?\K\.", r"_", cleanRow) # removing dots from variable names
                        cleanRow = regex.sub(r"[a-zA-Z]+?\S*?\K\,", r"_", cleanRow) # removing commas from variable names
                        cleanRow = regex.sub(r"der\(.*?\)", "0", cleanRow) # removing derivatives and setting them to 0 (JUST FOR STATIC PROBLEM!)
                        cleanRow = re.sub(r'\b([a-zA-Z_]\w*)\b', replace, cleanRow) # adding model name to variables (they must start with a letter!!) through function replace
                        cleanRow = re.sub(r"=", "==", cleanRow) # changing = into ==
                        cleanRow = re.sub(r"\^", "**", cleanRow) # changing ^ into **
                        cleanRow = re.sub(r";", "", cleanRow) # removing semicolumns
                        listExtraConstr.append(modelName + f".constrExtra{i} = Constraint(expr = " + cleanRow + ")\n\n")
                        i += 1
                
                elif staticOrDynamic == "Dynamic":
                    stringExtraVar = f"{modelName}.{varParamPyomo} = Var({modelName}.time, within = Reals)\n"
                    listExtraVars.append(stringExtraVar)
                    if initializationValues != None:
                        listExtraConstr.append(f"for t in timeSteps:\n\t{modelName}.{varParamPyomo}[t].fix({initializationValues[dictInitValues[varParam]][0]})\n\n")
                    else:
                        cleanRow = re.sub(r"[\[]", "_", row) # stripping square brackets
                        cleanRow = re.sub(r"[\]]", "", cleanRow) # stripping square brackets
                        cleanRow = re.sub(r"sqrt\(|exp\(|log\(|sin\(|cos\(", r"\g<0> ", cleanRow) # Adding space after log(, exp(, sqrt(
                        cleanRow = regex.sub(r"[a-zA-Z]+?\S*?\K\.", r"_", cleanRow) # removing dots from variable names
                        cleanRow = regex.sub(r"[a-zA-Z]+?\S*?\K\,", r"_", cleanRow) # removing commas from variable names
                        cleanRow = regex.sub(r'der\((\w+)\)', r'DER\1', cleanRow) # Replace der() with DER...
                        cleanRow = re.sub(r'\b([a-zA-Z_]\w*)\b', replace, cleanRow) # adding model name to variables (they must start with a letter!!) m.x
                        cleanRow = re.sub(r"=", "==", cleanRow) # changing = into ==
                        cleanRow = re.sub(r"\^", "**", cleanRow) # changing ^ into **
                        cleanRow = re.sub(r";", "", cleanRow) # removing semicolumns
                        cleanRow = re.sub(patternDynConstr, addInitialIndex, cleanRow)
                        cleanRow = re.sub(f"{modelName}.{varParamPyomo}\[tStart\]", f"{modelName}.{varParamPyomo}[t]", cleanRow)
                        listExtraConstr.append(f"def _constrExtra{i}({modelName},t):\n\treturn {cleanRow}\n\n{modelName}.constrExtra{i}({modelName}.time, rule = _constrExtra{i})\n\n")
                        i += 1

    if listExtraVars != []:
        listExtraVars.append("\n")
    return listExtraVars, listExtraConstr


def textSubLogVarsPyomoCode(replVarLogDict, modelName, staticOrDynamic):
    # Variables for the u variables in the log substitution are instantiated with this function (log(x) = u)
    def addValue(match):
        return match.group(1) + '.value'
    # Pattern to find variables and add to them .value method
    pattern = rf'\b({modelName}\.[a-zA-Z0-9_]+)\b'
    # Empty list to store the Pyomo code for the log substitution variables
    subLogVarsPyomoCode = []
    n = len(replVarLogDict.keys())
    if staticOrDynamic == "Dynamic":
        for i in range(n):
            # stringInit = re.sub(pattern, addValue, replVarLogDict[i+1])
            logArgument = re.sub(r"\[t\]", r"[m.time.ordered_data()[0]]",replVarLogDict[i+1])
            subLogVarsPyomoCode.append(f"{modelName}.u{i+1} = Var(m.time, initialize = log(" + logArgument + f"), within = Reals)\nm.scaling_factor[{modelName}.u{i+1}] = 1\n")
    elif staticOrDynamic == "Static":
        for i in range(n):
            stringInit = re.sub(pattern, addValue, replVarLogDict[i+1])
            subLogVarsPyomoCode.append(f"{modelName}.u{i+1} = Var(initialize = log(" + stringInit + f"), within = Reals)\nm.scaling_factor[{modelName}.u{i+1}] = 1\n")
    
    if subLogVarsPyomoCode != []:
        subLogVarsPyomoCode.append("\n")
    
    return subLogVarsPyomoCode

def mapTimeSteps(listOfAbscissaVects, pyomoTimeSteps):
    # This function links the time steps of the Modelica simulation and the ones of the Pyomo discretization for every abscissa found in the DyMat dictionary
    # listOfAbscissaVects is a list of abscissa vectors of the Modelica variables
    # pyomoTimeSteps is the list of time steps of the Pyomo simulation
    i = 0
    indicesTimeStepsModelicaSim = {}
    for abscissaVect in listOfAbscissaVects:
        indicesTimeStepsModelicaSim[i] = []
        for t in pyomoTimeSteps:
            listClosest = [abs(t-ts) for ts in abscissaVect]
            indicesTimeStepsModelicaSim[i].append(listClosest.index(min(listClosest)))
        i += 1

    return indicesTimeStepsModelicaSim

def identifyResultsAbscissa(initializationValuesDict):
    # This function identifies the different abscissa vectors of the variables of the Modelica results file and creates a list of abscissa 
    # vectors and a dictioanary of variables and respective abscissa index in the list of abscissa vectors
    listOfAbscissaVects = [] # The list of all abscissa vectors found in the results file
    varAbscissaDict = {} # Dictionary with variable names as key and index of corresponding abscissa in listOfAbscissaVects
    varNames = list(initializationValuesDict.names())
    for name in varNames:
        abscissa = initializationValuesDict.abscissa(name)[0] 
        found = False
        i = 0
        for vect in listOfAbscissaVects:
            try:
                if (abscissa == vect).all():
                    varAbscissaDict[name] = i
                    found = True
            except:
                pass
            i += 1
        if found == False:
            listOfAbscissaVects.append(abscissa)
            varAbscissaDict[name] = len(listOfAbscissaVects)-1

    return listOfAbscissaVects, varAbscissaDict

def writeTextDynamicTrajectoryInit(modelName, modelicaResults, variablesDict, varAbscissaDict, indicesTimeStepsModelicaSim, dictInitValues, replVarLogDict, statesDict):
    trajInitLineList = [f"import DyMat\nresForInitTraj = DyMat.DyMatFile('{modelicaResults}')\n"]
    for indexVect in indicesTimeStepsModelicaSim.keys():
        trajInitLineList.append(f"abscissa{indexVect} = {indicesTimeStepsModelicaSim[indexVect]}\n")    
    
    trajInitStringBeginFor = "for t, "
    trajInitStringSecondPartFor = " in zip(timeSteps, "
    for indexVect in indicesTimeStepsModelicaSim.keys():
        trajInitStringBeginFor += f"indAbscissa{indexVect}, "
        trajInitStringSecondPartFor += f"abscissa{indexVect}, "
    
    trajInitLineList.append(trajInitStringBeginFor[:-2] + trajInitStringSecondPartFor[:-2] + "):\n")

    for var in variablesDict.keys():
            trajInitLineList.append(f"\t{modelName}.{variablesDict[var]['pyomoName']}[t] = resForInitTraj['{dictInitValues[var]}'][indAbscissa{varAbscissaDict[var]}]\n")
    
    for subLogVar in replVarLogDict.keys():
        trajInitLineList.append(f"\t{modelName}.u{subLogVar}[t] = log({replVarLogDict[subLogVar]})\n")

    for state in statesDict.keys():
        derVarModelicaName = f"der({state})"
        derVarPyomoName = f"DER{statesDict[state]}"
        trajInitLineList.append(f"\t{modelName}.{derVarPyomoName}[t] = resForInitTraj['{dictInitValues[derVarModelicaName]}'][indAbscissa{varAbscissaDict[state]}]\n")
    
    trajInitLineList.append("\n")    

    return trajInitLineList
    

def m2p(modelicaModel, pyomoModel, modelicaResults, modelName, solverName, staticOrDynamic, initConditions, initTrajectory,
         customLinesBeforeSettings, customLinesAfterSettings, tStart = 0, tEnd = 1, bounds = True,
         subLog = False, dynTransfOpt = dict()):
    # This is the main function of this script. You should call this function in another script as shown in *example.py* to generate the Pyomo model
    # Input description:
    # - modelicaModel: string containing the path of the modelica model to translate into a Pyomo model
    # - pyomoModel: string containing path of the Pyomo model to be generated
    # - modelicaResults: string containing path of the optional modelica results file
    # - modelName = string containing the name of the Pyomo model instance (for example m.)
    # - solverName = string containing the name of the optimization solver to be called with Pyomo with the SolverFactory object
    # - staticOrDynamic = string that is either "Static" or "Dynamic" to tell the compiler if the optimization problem is either static or dynamic
    # - initConditions = string that is either "KEEP-MODELICA" or "FIX-STATES" to tell the compiler if it should keep the initial equations of the 
    #                       Modelica model or use the results file to fix the values of the variables appearing in the der() operator
    #                       at time instant zero
    # - customLinesBeforeSettings: string containing the 
    # - customLinesAfterSettings: string containing the 
    # - tStart: float containing the start time of the dynamic simulation
    # - tEnd: float containing the end time of the dynamic simulation
    # - initTrajectory: string specifying either the initialization follows a "Constant" or "Dynamic" trajectory (options="Constant" or "Dynamic").
    # - bounds: boolean (True or False). If True enforce bounds through the "bounds" keyword in the Var declaration *based on min and max attributes of 
    #               Base Modelica model. If False, do not use "bounds" keyword
    # - subLog: boolean (True or False). If true perform log substitution with equivalent exponential expression
    # - dynTransfOpt: dictionary with options for the collocation or finite difference discretization.
    #                       Example for collocation:
    #                           dynTransfOpt = dict()
    #                           dynTransfOpt["methodeName"] = "dae.collocation"
    #                           dynTransfOpt["nfe"] = "10" # Number of finite elements for collocation as string
    #                           dynTransfOpt["ncp"] = "3" # Number of collocation points in finite element as string
    #                           dynTransfOpt["scheme"] = "LAGRANGE-RADAU"
    #
    #                       Example for finite difference (no "ncp" for finite difference):
    #                           dynTransfOpt = dict()
    #                           dynTransfOpt["methodeName"] = "dae.finite_difference"
    #                           dynTransfOpt["nfe"] = "10" # Number of finite elements for finte differences as string
    #                           dynTransfOpt["scheme"] = "BACKWARD"


    # Opening the flat Modelica model file and creating a list with the rows of the file
    if staticOrDynamic != "Dynamic" and  staticOrDynamic != "Static":
        sys.exit(f"Wrong staticOrDynamic flag --> assigned = '{staticOrDynamic}', allowed values are 'Static' or 'Dynamic")
    
    if initTrajectory != "Dynamic" and  initTrajectory != "Constant":
        sys.exit(f"Wrong initTrajectory flag --> assigned = '{initTrajectory}', allowed values are 'Constant' or 'Dynamic")

    with open(modelicaModel) as my_file:
        baseModelica = my_file.readlines()
    
    # Creating a dictionary with the content of the DyMat file for the initialization values of the variables of the problem and 
    # a map between the Modelica .mat file names and the Base Modelica names
    try:
        initializationValues = DyMat.DyMatFile(modelicaResults)
        dictInitValues = mapMatFileToOMC(initializationValues)
        # If a Dynamic problem is created and a Dynamic trajectory is employed, build the timeSteps list for the selected discretization scheme and 
        # create a map between the Pyomo time steps and the Modelica simulation time steps (notice that different Modelica time discretization might 
        # be present in the results file
        if staticOrDynamic == "Dynamic" and initTrajectory == "Dynamic":
            from pyomo.environ import (ConcreteModel,TransformationFactory)
            from pyomo.dae import ContinuousSet
            import numpy as np

            m = ConcreteModel()
            numOfIntervals = eval(dynTransfOpt["nfe"])
            m.time = ContinuousSet(initialize = np.linspace(tStart,tEnd,numOfIntervals+1))
            discretizer = TransformationFactory(dynTransfOpt["methodeName"])
            discretizer.apply_to(m, nfe=numOfIntervals, ncp=eval(dynTransfOpt["ncp"]), scheme=dynTransfOpt["scheme"])
            timeSteps = [h for h in m.time]
        
            listOfAbscissaVects, varAbscissaDict = identifyResultsAbscissa(initializationValues)
            indicesTimeStepsModelicaSim = mapTimeSteps(listOfAbscissaVects, timeSteps)
    
    except:
        initializationValues = None
        dictInitValues = None
    
    # Removing comments and other unwanted characters from the Base Modelica model
    baseModelica = cleanBaseModelica(baseModelica)

    # Removing if initial() then else end if structures keeping the else equations
    baseModelica = removeIfInitial(baseModelica)

    # Finding the beginning of the model, the beginning of the equation section and the end of the model
    # First baseModelica structure before removal of Algorithms and TimeTables
    equationStart, initialEquationStart, algoStarts = modelicaModelStructure(baseModelica)

    # If algorithms are present, remove them: notice that this is intended for the removal of algorithm introduced by TimeTables
    # If other algorithm are present, they should be elimininated from the Modelica model before the translation
    if algoStarts != []:
        baseModelica, algoSections = extractAlgorithmSection(baseModelica, algoStarts)
    
    # Function to handle the code of TimeTables and CombiTimeTables
    baseModelica, timeTablesDict = timeTableHandler(baseModelica,equationStart)

    # Function to update the dictionary containing the data of the TimeTables and CombiTimeTabnles with the data stored on external files 
    timeTablesDict = timeTableOnFileHandler(timeTablesDict)

    if timeTablesDict != {}:
        # If TimeTable or CombiTimeTable data are available, write the Pyomo code of such tables
        pyomoTableCode = timeTablesConstraintPyomoCode(timeTablesDict, modelName, staticOrDynamic)
        if pyomoTableCode != []:
            pyomoTableCode.insert(0,"# Code for the instantiation of the time tables\n")
    else:
        pyomoTableCode = []
    
    # Update Base Modelica structure after removal of Algorithms and TimeTables
    equationStart, initialEquationStart, algoStarts = modelicaModelStructure(baseModelica)

    baseModelica, stepsAndRamps = extractStepsAndRamps(baseModelica, equationStart)

    if stepsAndRamps == {}:
        pyomoCodeStepAndRamps = []
    else:
        pyomoCodeStepAndRamps = pyomoStepAndRamps(stepsAndRamps, modelName)
        if pyomoCodeStepAndRamps != []:
            pyomoCodeStepAndRamps.insert(0,"# Code for the translation of steps and ramps\n")

    # Creating a dictionary with all the variables of the model, with name, pyomo name, min, max, nominal and initialization value
    variablesDict = varsDict(baseModelica, initialEquationStart, initializationValues = initializationValues, dictInitValues = dictInitValues)

    # Takes as input variablesDict to create Pyomo code in list to instantiate variables and scale them
    # The following list contains Pyomo code (each entry is a line of code)
    varPyomoCode = textVarPyomoCode(variablesDict, modelName, staticOrDynamic, initTrajectory = initTrajectory, bounds = bounds)
    if varPyomoCode != []:
        varPyomoCode.insert(0,"# Writing the code for variable instantiation\n")

    # Fixing variable and creating constraints 
    # The following list contains Pyomo code (each entry is a line of code)
    # Generation also of a dictionary of states and their corresponding Pyomo variables and a dictionary of log substitutions
    constraintsPyomoCode, statesDict, replVarLogDict = textConstraintsPyomoCode(baseModelica, equationStart, modelName, variablesDict, staticOrDynamic = staticOrDynamic, subLog = subLog)
    if constraintsPyomoCode != []:
        if constraintsPyomoCode[0] != []:
            constraintsPyomoCode[0].insert(0, "# Instantiating the problem constraints\n")
        if constraintsPyomoCode[1] != []:
            constraintsPyomoCode[1].insert(0, "# Instantiating the problem constraints for the manipulated logarithms\n")

    # Handling Modelica's fixed = false parameters: the results file must be provided in this case! Otherwise this function will implement additional constraints setting fixFalseParam = f(t=0) for the entire simulation!
    fixedFalseParamsVars, fixedFalseParamsConstr = fixedFalseParams(baseModelica, modelName, initialEquationStart, equationStart, staticOrDynamic, initializationValues, dictInitValues)
    if fixedFalseParamsVars != []:
        fixedFalseParamsVars.insert(0,"# Instantiating the variables for the fixed = false parameters\n")
    if fixedFalseParamsConstr != []:
        fixedFalseParamsConstr.insert(0,"# Instantiating the constraints for the fixed = false parameters\n")

    # Handling log substitution variables and writing the Pyomo code
    subLogVarsPyomoCode = textSubLogVarsPyomoCode(replVarLogDict, modelName, staticOrDynamic)
    if subLogVarsPyomoCode != []:
        subLogVarsPyomoCode.insert(0,"# Instantiating the variables for the log arguments manipulation\n")

    # Handling DER variables and writing the Pyomo code
    DERpyomoCode = textDERpyomoCode(statesDict, modelName, initializationValues, dictInitValues)
    if DERpyomoCode != []:
        DERpyomoCode.insert(0,"# Instantiating the variables for the time derivatives\n")

    # Writing the Pyomo code for the initial conditions
    if staticOrDynamic == "Dynamic":
        initialConditionsCode = initialConditionsPyomoCode(modelName, initConditions, baseModelica, equationStart, initialEquationStart, 
                                  statesDict, initializationValues, dictInitValues)
        if initialConditionsCode != []:
            initialConditionsCode.insert(0,"# Code for the initial conditions of the dynamic optimization problem\n")
    else:
        initialConditionsCode = []

    # Initial guesses code for dynamic initial trajectories 
    if staticOrDynamic == "Dynamic" and initTrajectory == "Dynamic":
        textDynamicTrajectoryInit = writeTextDynamicTrajectoryInit(modelName, modelicaResults, variablesDict, varAbscissaDict, 
                                                                   indicesTimeStepsModelicaSim, dictInitValues, replVarLogDict, statesDict)
        if textDynamicTrajectoryInit != []:
            textDynamicTrajectoryInit.insert(0,"# Code for the guessed initial trajectories for the variables of the problem\n")
    else:
        textDynamicTrajectoryInit = []

    # Define the initial lines of the Pyomo file, importing packages and instantiating the model
    imports = f"""import idaes
from idaes.core.solvers.config import use_idaes_solver_configuration_defaults
from idaes.core.util import DiagnosticsToolbox
from pyomo.environ import (
    ConcreteModel,
    Var,
    PositiveReals,
    Objective,
    Constraint,
    ConstraintList,
    Suffix,
    Reals,
    log,
    exp,
    sqrt,
    sin,
    minimize,
    maximize,
    SolverFactory,
    TransformationFactory,
    value,
    summation)
from pyomo.core.expr import identify_variables
from pyomo.core.expr import differentiate
from pyomo.dae import (
    ContinuousSet,
    DerivativeVar)
import numpy as np
import re


{modelName} = ConcreteModel()

{modelName}.scaling_factor = Suffix(direction=Suffix.EXPORT)
"""
    # This string defines the time related variables if the problem is a dynamic one
    time = f"""
# Writing the code for the time variable instantiation
numOfIntervals = {dynTransfOpt["nfe"]}
ncp = {dynTransfOpt["ncp"]}
tStart = {tStart}
tEnd = {tEnd}
{modelName}.time = ContinuousSet(initialize = np.linspace(tStart,tEnd,numOfIntervals+1))
dt = tEnd/(numOfIntervals+1)/ncp

"""

    if staticOrDynamic == "Dynamic":
        # This string performs the scaling of the constraints and the objective function in case the problem is dynamic
        scaling = f"""
# Constraint normalization
for constr in {modelName}.component_objects(Constraint, active=True):
    varList = list(identify_variables(constr[list(constr.keys())[0]].body))
    listF = []
    for var in varList:
        varName = re.sub(r'\[.*\]', '', str(var))
        varName = "m." + varName
        listF.append(abs(differentiate(constr[list(constr.keys())[0]].body, wrt=var)/{modelName}.scaling_factor[eval(varName)]))
    {modelName}.scaling_factor[constr] = 1/max(listF)

# Objective function normalization
varList = list(identify_variables({modelName}.obj))
listF = []
for var in varList:
    varName = re.sub(r'\[.*\]', '', str(var))
    varName = "m." + varName
    listF.append(abs(differentiate({modelName}.obj, wrt=var)/{modelName}.scaling_factor[eval(varName)]))
    
if listF != []:    
    {modelName}.scaling_factor[{modelName}.obj] = 1/max(listF)

"""
    
    elif staticOrDynamic == "Static":
        # This string performs the scaling of the constraints and the objective function in case the problem is static
        scaling = f"""
# Constraint normalization
for constr in {modelName}.component_objects(Constraint, active=True):
    varList = list(identify_variables(constr.body))
    listF = []
    for var in varList:
        varName = re.sub(r'\[.*\]', '', str(var))
        varName = "m." + varName
        listF.append(abs(differentiate(constr.body, wrt=var)/{modelName}.scaling_factor[eval(varName)]))
    {modelName}.scaling_factor[constr] = 1/max(listF)

# Objective function normalization
varList = list(identify_variables({modelName}.obj))
listF = []
for var in varList:
    varName = re.sub(r'\[.*\]', '', str(var))
    varName = "m." + varName
    listF.append(abs(differentiate({modelName}.obj, wrt=var)/{modelName}.scaling_factor[eval(varName)]))
    

if listF != []:      
    {modelName}.scaling_factor[{modelName}.obj] = 1/max(listF)

"""
    # If the problem is dynamic, the time discretization of the model should be performed, either via collocation of finite differences
    if staticOrDynamic == "Dynamic":
        if dynTransfOpt["methodeName"] == "dae.collocation":
            transformationsDAE = f"""
# Applying time discretization through direct collocation to the problem
discretizer = TransformationFactory('dae.collocation')
discretizer.apply_to({modelName}, nfe=numOfIntervals, ncp=ncp, scheme='{dynTransfOpt["scheme"]}')

timeSteps = [h for h in m.time]

"""
        elif dynTransfOpt["methodeName"] == "dae.finite_difference":
            transformationsDAE = f"""
# Applying time discretization through finite difference to the problem
discretizer = TransformationFactory('dae.finite_difference')
discretizer.apply_to({modelName}, nfe=numOfIntervals, scheme='{dynTransfOpt["scheme"]}')

timeSteps = [h for h in m.time]

"""
        else:
            print("Error assigning model transformation!")

    # This string contains the solver optins to attach at the end of the Pyomo file (it has some defaults, can be modified to suit better the problem)
    solverSettings = f"""
# Solver settings and problem solution
scaled_model = TransformationFactory('core.scale_model').create_using({modelName})
use_idaes_solver_configuration_defaults()
solver = SolverFactory("{solverName}")
results = solver.solve(scaled_model, tee=True, logfile="log.txt")
TransformationFactory('core.scale_model').propagate_solution(scaled_model, {modelName})
"""

    with open(pyomoModel,"w") as pyfile:
        # Write file beginning and model instantiation
        pyfile.write(imports)
        # If the problem is dynamic include options for time discretization
        if staticOrDynamic == "Dynamic":
            pyfile.write(time)
        # Write the Pyomo code for the variables
        for lineVar in varPyomoCode:
            pyfile.write(lineVar)
        # Write the Pyomo code for the fixed = false parameters of the Modelica model
        for falseParam in fixedFalseParamsVars:
            pyfile.write(falseParam)
        # Inlcude in the variables the newly created ones to substitute the log functions
        for lineSubLog in subLogVarsPyomoCode:
            pyfile.write(lineSubLog)
        # Include the dreivatives among the vars if the problem is a dynamic one
        if staticOrDynamic == "Dynamic":
            for lineDER in DERpyomoCode:
                pyfile.write(lineDER)
        # Write the Pyomo code for the discretization of the variables according to the chosen method
        if staticOrDynamic == "Dynamic":
            pyfile.write(transformationsDAE)
        for initTrajLine in textDynamicTrajectoryInit:
            pyfile.write(initTrajLine)
        # Write the Pyomo code for the constraints of the log substitution
        for lineSubLog in constraintsPyomoCode[1]:
            pyfile.write(lineSubLog)
        # Write the Pyomo code for the constraints of the fixed = false parameters
        for falseParamConstr in fixedFalseParamsConstr:
            pyfile.write(falseParamConstr)
        # Write the Pyomo code for the constraints
        for lineConstr in constraintsPyomoCode[0]:
            pyfile.write(lineConstr)
        for lineTimeTables in pyomoTableCode:
            pyfile.write(lineTimeTables)
        for lineStepAndRamp in pyomoCodeStepAndRamps:
            pyfile.write(lineStepAndRamp)
        # Write the code of custom lines before the final Pyomo settings (the objective function should be here)
        pyfile.write(customLinesBeforeSettings)
        # Write the Pyomo code for the initial equations
        for lineInit in initialConditionsCode:
            pyfile.write(lineInit)
        # Write the code for the scaling of the constraints and of the objective function
        pyfile.write(scaling)
        # Write the Pyomo code for the solver settings
        pyfile.write(solverSettings)
        # Write the code of custom lines after the final Pyomo settings
        pyfile.write(customLinesAfterSettings)
        
    return

